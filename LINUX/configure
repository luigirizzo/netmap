#!/bin/sh

BUILDDIR=$PWD
SRCDIR=$(cd $(dirname $0); pwd)
MODNAME=netmap
DEBUG=1
UTILS=1
DRVERRFAIL=
DMASYNC=1

# setelem2n <set> <elem>
setelem2n()
{
	local i=1
	local n
	for n in $(eval echo \$$1_avail); do
		if [ $n = $2 ]; then
			echo $i
			return
		fi
		i=$((2 * i))
	done
}

# setop <set> <op> [<elem>]
setop()
{
	local w
	local n
	local s
	local e

	case "$2" in
	new)
		eval "$1_avail=\$$3_avail; $1="
		return
		;;
	copy)
		eval "$1=\$$3"
		return
		;;
	intersect)
		eval "$1=\$(($1 & $3))"
		return
		;;
	subtract)
		eval "$1=\$(($1 & ~$3))"
		return
		;;
	esac

	if [ -n "$3" ]; then
		w=$(setelem2n $1 $3)
		[ -n "$w" ] || {
			echo "unknown $1: $3" | warning
			return
		}
	fi
	case "$2" in
	is-empty)
		[ $(eval echo \$$1) -eq 0 ]
		;;
	disable-all)
		eval "$1=0"
		;;
	enable-all)
		eval "$1=0"
		s=$(eval echo \$$1_avail)
		for n in $s; do
			eval "$1=\$(( ($1 << 1) | 1))"
		done
		;;
	enable)
		eval "$1=\$(($1 | $w))"
		;;
        disable)
		eval "$1=\$(($1 & ~$w))"
		;;
        enabled)
		eval "w=\$(($1 & $w))"
		[ $w -ne 0 ]
		;;
	print)
		s=$(eval echo \$$1_avail)
		e=
		for n in $s; do
			w=$(setelem2n $1 $n)
			eval "w=\$(($1 & $w))"
			[ $w -ne 0 ] && e="$n $e"
		done
		echo $e
		;;
        esac
}

# available subsystems
subsystem_avail="vale pipe monitor generic ptnetmap sink \
	extmem null"
#enabled subsystems (bitfield)
subsystem=0

subsys()
{
	setop subsystem "$@"
}

subsys enable vale
subsys enable pipe
subsys enable monitor
subsys enable generic
subsys enable null
subsys enable ptnetmap

# available drivers
driver_avail="stmmac r8169.c virtio_net.c forcedeth.c veth.c \
	e1000 e1000e igb ixgbe ixgbevf ice i40e vmxnet3 mlx5"
# enabled drivers (bitfield)
driver=
drv()
{
	setop driver "$@"
}

drv enable-all

# drivers built by external commands (subset of driver)
setop external_driver new driver
edrv()
{
	setop external_driver "$@"
}

edrv enable e1000e
edrv enable igb
edrv enable ixgbe
edrv enable ixgbevf
edrv enable i40e
edrv enable ice
edrv enable mlx5
edrv enable virtio_net.c

# drivers built by patching the system drivers
setop internal_driver new driver
idrv()
{
	setop internal_driver "$@"
}

# external drivers that don't need the pre-patch test
setop custom_driver new driver
cdrv()
{
	setop custom_driver "$@"
}

cdrv enable virtio_net.c

update_drivers() {
	edrv intersect driver
	idrv copy driver
	idrv subtract external_driver
}

update_drivers

# available apps
application_avail="pkt-gen bridge lb tlem nmreplay vale-ctl dedup"
application=0
app()
{
	setop application "$@"
}
# enable all by default
app enable-all

prefix=/usr/local
cc=cc
ld=ld

# with <command>: success iff <command> is available
with() {
	type $1 >/dev/null 2>&1
}

print_realpath() {
	if with realpath; then
		rp=$(realpath "$1")
		if [ "$rp" != "$1" ]; then
			echo "                            [$rp]"
		fi
	fi
}

decode_version() {
	if [ -n "$1" ] && with perl; then
		echo " [$($SRCDIR/scripts/vers $1 -C)]"
	fi
}

# report: print the current state of the configuration variables
report() {
	echo "kernel directory            $ksrc"
	print_realpath $ksrc
	echo "kernel sources              $src"
	print_realpath "$src"
	local v=$lin_ver
	[ -n "$v" ] || v="-"
	local dv="$(decode_version $lin_ver)"
	echo "linux version               $v $dv"
	echo "module file                 $MODNAME.ko"
	echo
	echo "subsystems                  $(subsys print)"
	echo "apps                        $(app print)"
	echo "native drivers              $(drv print)"
	echo
	if [ -f "drivers.mak" ]; then
		cat <<EOF
Contents of the drivers.mak file:
EOF
		cat drivers.mak
	fi
}

message()
{
	{
		cat <<EOF
********************************** $1 **********************************
EOF
		sed 's/^/*** /' # output the error message from stdin
	if [ -n "$2" ]; then
		cat <<EOF
***
***
***     Current configuration values:
***
EOF
		report | sed 's/^/*** /'
	fi
		cat <<EOF
*****************************************************************************
EOF
	} | tee -a config.log
}

# error: format an error msg containing the lines read from stdin
# 	and exit with failure.
error() {
	message " ERROR " true
	exit 1
}

warning()
{
	message WARNING
}

drverror() {
	message WARNING
	if [ -n "$DRVERRFAIL" ]; then
		error <<EOF
Exiting because of --fail-on-driver-errors.
EOF
	fi
}

replace_vars()
{
	sed \
		-e "s|@BUILDDIR@|$BUILDDIR|g" \
		-e "s|@SRCDIR@|$SRCDIR|g" \
		-e "s|@TMPDIR@|$TMPDIR|g" \
		-e "s|@KSRC@|$ksrc|g" \
		-e "s|@SRC@|$src|g" \
		-e "s|@KOPTS@|$kopts|g" \
		-e "s|@MODPATH@|$modpath|g" \
		-e "s|@MODNAME@|$MODNAME|g" \
		-e "s|@SUBSYS@|$(subsys print)|g" \
		-e "s|@LIN_VER@|$lin_ver|g" \
		-e "s|@MOD_LIST@|$mod_list|g" \
		-e "s|@PATCHES@|$(echo $patches)|g" \
		-e "s|@S_DRIVERS@|$(drv print)|g" \
		-e "s|@E_DRIVERS@|$(edrv print)|g" \
		-e "s|@I_DRIVERS@|$(idrv print)|g" \
		-e "s|@DRVSUFFIX@|$drvsuffix|g" \
		-e "s|@APPS_LIST@|$(app print)|g" \
		-e "s|@APPS_CC@|$cc|g" \
		-e "s|@APPS_LD@|$ld|g" \
		-e "s|@PREFIX@|$prefix|g" \
		-e "s|@DESTDIR@|$DESTDIR|g" \
		-e "s|@DEBUG@|$DEBUG|g" \
		-e "s|@UTILS@|$UTILS|g" \
		-e "s|@REC_DISABLED_WARNINGS@|$REC_DISABLED_WARNINGS|g" \
		$1
}

# print_help
print_help() {
	cat <<EOF
Available options:

  --help                       print this message
  --kernel-dir=                path to configured kernel directory
  --kernel-sources=            path to full kernel sources
  --kernel-version=	       specify the kernel version
  				(assuming everything is in the default place)
  --kernel-opts=	       additional options to pass to kernel make
                               (you can call this several times)
  --install-mod-path=          where the modules will be installed
  --driver-suffix=             add suffix to the patched modules names
  --no-drivers                 do not compile any driver
  --no-drivers=                do not compile the given drivers (comma sep.)
  --drivers=                   only compile the given drivers (comma sep.)
  --no-ext-drivers             do not use external drivers
  --no-ext-drivers=            do not use the given external drivers (comma sep.)
  --select-version=	       comma sep. list of driver:version expressions
  			       (select a different versions for external drivers)
  --fail-on-driver-errors      stop the build when a driver fails to compile,
			       rather than disabling it
  --no-apps	               do not compile any app
  --no-apps=                   do not compile the given apps (comma sep.)
  --apps=                      only compile the given apps (comma sep.)
  --no-utils		       do not compile the utils
  --mod-name=		       netmap module name [$MODNAME]
  --enable-vale      	       enable the VALE switch
  --disable-vale      	       disable the VALE switch
  --enable-pipe      	       enable the netmap pipes
  --disable-pipe      	       disable the netmap pipes
  --enable-monitor   	       enable the nemtap monitors
  --disable-monitor   	       disable the nemtap monitors
  --enable-generic   	       enable the generic netmap adapter
  --disable-generic   	       disable the generic netmap adapter
  --enable-ptnetmap            enable ptnetmap
  --disable-ptnetmap           disable ptnetmap
  --enable-sink   	       enable the netmap sink device
  --disable-sink   	       disable the netmap sink device
  --enable-extmem   	       enable the external memory allocators
  --disable-extmem   	       disable the external memory allocators
  --force-debug	       	       build the modules w/ debug symbols (default)
  --no-force-debug	       build the modules w/ or w/o debug symbols,
  --cache=		       dir for reusing/caching of netmap_linux_config.h
  --without-dmasync	       use this if you are on x86 with a recent NIC and no IOMMU

  --cc=                        C compiler to be used for the apps and utils [$cc]
  --ld=                        linker to be used for the apps and utils [$ld]
  --prefix=                    install path for the apps and utils [$prefix]
  --destdir=                   destination dir for the apps and utils [$DESTDIR]

  --show-drivers	       print the list of available drivers and exit
  --show-ext-drivers	       print the list of available external drivers and exit
  --show-apps	       	       print the list of available apps and exit

EOF
}

#################################################################
# machinery for the creation of netmap_linux_config.h           #
#################################################################

# We check for the availability/version of several linux
# internal APIs by running compilation tests. The results
# of the tests will produce a set of macros in the
# 'netmap_linux_config.h' file. All macros names begin
# with 'NETMAP_LINUX'.

# TMPDIR is where we build all the tests
TMPDIR=netmap-tmpdir

# tests are first accumulated using add_named_test and add_test, then
# run by run_tests. This setup amortizes the cost of going
# through linux kbuild and opens the opportunity of using the '-j'
# flag of make. Speedup is in the order of x10.

# TESTOBJS will contain the list of test modules to build
TESTOBJS=
# TESTPOSTPROC will contain a script that runs the pertinent
# 'on success' or 'on failure' action for each test at the
# end of 'run_tests'.
TESTPOSTPROC=

# add_file_exists_check <file-name> <on success> [<on failure>]
add_file_exists_check()
{
	cmd="if [ -f "$TMPDIR/$1" ]; then $2"
	[ -n "$3" ] && cmd="$cmd; else $3"
	cmd="$cmd; fi"
	cat >> config.log <<EOF
##############################################################################
## cmd: $cmd
##############################################################################
EOF
	TESTPOSTPROC="$cmd; $TESTPOSTPROC"
}

# add_named_test <test-name> [<on success> [<on failure>]]:
#     the test code is read from stdin, completed with
#     some standard modules boiler plate and put in
#     $TMPDIR/test-name.c for future compilation by 'run_tests'.
#     The optional <on success> script (which must be a single
#     argument) will be executed if $TMPDIR/test-name.o will
#     be correctly created. The optional <on failure>
#     script (one argument) will be executed if compilation fails.
#
#     Note: add_test (below) is preferred. Use add_named_test
#     only if you need to do some complex check for which you need to
#     know the name of the test files.
add_named_test() {
	{
		cat <<EOF
	#include <linux/module.h>
	#include <linux/kernel.h>
	#include <linux/init.h>
EOF
		cat	# output the test code read from stdin
		cat <<EOF
	MODULE_LICENSE("GPL");
EOF
	} > $TMPDIR/$1.c
	{
		cat <<EOF
##############################################################################
##            TEST:  $1
##############################################################################
EOF
		cat $TMPDIR/$1.c
	} >> config.log
	# add the module to the running list
	TESTOBJS="$1.o $TESTOBJS"
	# add the postprocess script for this test
	if [ -n "$2" ]; then
		add_file_exists_check "$1.o" "$2" "$3"
	fi
}

# add_test [<on success> [<on failure>]]
#     used like add_named_test above, but without the need of
#     explicitly naming the test.
NEXTTEST=1
add_test() {
	local t="__test__$NEXTTEST"
	add_named_test $t "$@"
	NEXTTEST=$(($NEXTTEST+1))
}

reset_tests() {
	rm -rf $TMPDIR
	mkdir $TMPDIR

	TESTOBJS=
	TESTPOSTPROC=
	NEXTTEST=1
	cat >> config.log <<EOF
##############################################################################
##		NEW TESTS
##############################################################################
EOF
}

# run_preliminary_tests: this must be run before run_tests. It checks some
# options related to the build system itself and sets some variables later
# used by run_tests.
run_preliminary_tests() {
	{
		cat <<EOF
ifneq (\$(KERNELRELEASE),)
obj-m := $TESTOBJS
EOF
		if [ -e $TMPDIR/extra.mk ]; then cat $TMPDIR/extra.mk; fi
		cat <<EOF
else

all:
	\$(MAKE) -C $ksrc M=\$\$PWD EXTRA_CFLAGS="\$(EXTRA_CFLAGS)" $kopts
endif
EOF
	} > $TMPDIR/Makefile
	NPROC=$(grep -c processor /proc/cpuinfo)
	MAKE_OPT=-O
	{
		cat <<EOF
##############################################################################
## BEGIN RUNNING PRELIMINARY TESTS: $(date)
##############################################################################
## Makefile:
EOF
		cat $TMPDIR/Makefile
		cat <<EOF
##############################################################################
EOF
	} >> config.log
	(
		cd $TMPDIR
		LANG=C make $MAKE_OPT -k -j $NPROC
	) >> config.log 2>&1
	if grep -q ": invalid option -- 'O'" config.log; then
		MAKE_OPT=
		# let us try again without -O
		(
			cd $TMPDIR
			make -k -j $NPROC
		) >> config.log 2>&1
	fi
	eval "$TESTPOSTPROC"
	cat >> config.log <<EOF
##############################################################################
## END RUNNING PRELIMINARY TESTS: $(date)
##############################################################################
EOF
}

# run_tests: run all accumulated tests and exec the pertinent
#   success/failure actions for each one.
run_tests() {
	ln -s $BUILDDIR/patches $TMPDIR
	cat > $TMPDIR/Makefile <<EOF
SRCDIR=$SRCDIR
ifneq (\$(KERNELRELEASE),)
obj-m := $TESTOBJS
else
WARN_CFLAGS := -Werror \$(addprefix -Wno-error=,$REC_DISABLED_WARNINGS)
S_DRIVERS := $(drv print)
E_DRIVERS := $(edrv print)
C_DRIVERS := $(cdrv print)
I_DRIVERS := $(idrv print)

TOBUILD := \$(filter-out \$(C_DRIVERS),\$(E_DRIVERS))

all: \$(S_DRIVERS:%=get-%) \$(TOBUILD:%=build-%) \$(I_DRIVERS:%=patch-%) tests

tests:
	\$(MAKE) -C $ksrc M=\$\$PWD EXTRA_CFLAGS="\$(WARN_CFLAGS)" $kopts

-include $BUILDDIR/extdrv-versions.mak
-include $BUILDDIR/default-config.mak
-include $BUILDDIR/config.mak
-include $BUILDDIR/drivers.mak
EOF
	for d in $(drv print); do
		cat >> $TMPDIR/Makefile <<EOF
get-$d:
	\$($d@fetch)
	\$($d@src)
	touch get-$d
prepare-$d: get-$d
	\$($d@prepare)
	touch prepare-$d
build-$d: prepare-$d
	+\$($d@build)
	touch build-$d
patch-$d: get-$d
	\$(foreach p,\$($d@patch),patch --quiet --force -p1 < \$(p);)
	touch patch-$d
EOF
	done
	echo endif >> $TMPDIR/Makefile
	{
		cat <<EOF
##############################################################################
## BEGIN RUNNING TESTS: $(date)
##############################################################################
## Makefile:
EOF
		cat $TMPDIR/Makefile
		cat <<EOF
##############################################################################
EOF
	} >> config.log
	(
		cd $TMPDIR
		make $MAKE_OPT -k -j $NPROC
	) >> config.log 2>&1
	eval "$TESTPOSTPROC"
	cat >> config.log <<EOF
##############################################################################
## END RUNNING TESTS: $(date)
##############################################################################
EOF
}

configh=netmap_linux_config.h
# success/failure actions are expected to write some macros
# in netma_linux_config.h. The following functions can be
# used to simplify the task.

# define <macro> <value>: define NETMAP_LINUX_<macro> as <value>
define() {
	cat >> $configh <<EOF

		#define NETMAP_LINUX_$1 $2
EOF
}

# have <macro>: define NETMAP_LINUX_HAVE_<macro>
have() {
	define "HAVE_$1"
}


############################
# parse options
############################
ksrc=
src=
kopts=
modpath=
drvsuffix=
cache=
versions=
for opt do
	optarg=${opt#*=}
	case "$opt" in
	--kernel-dir=*) ksrc="$optarg"
	;;
	--kernel-sources=*) src="$optarg"
	;;
	--kernel-version=*) ksrc="/lib/modules/$optarg/build"
	;;
	--kernel-opts=*) kopts="$kopts $optarg"
	;;
	--install-mod-path=*) modpath="$optarg"
	;;
	--driver-suffix=*) drvsuffix="$optarg"
	;;
	--no-drivers) drv disable-all
	;;
	--no-drivers=*)
		drv enable-all
		for d in $(echo "$optarg" | sed 's/,/ /g'); do
			drv disable "$d"
		done
	;;
	--no-ext-drivers) edrv disable-all
	;;
	--no-ext-drivers=*)
		for d in $(echo "$optarg" | sed 's/,/ /g'); do
			edrv disable "$d"
		done
	;;
	--drivers=*)
		drv disable-all
		for d in $(echo "$optarg" | sed 's/,/ /g'); do
			drv enable "$d"
		done
	;;
	--no-apps) app disable-all
	;;
	--no-apps=*)
		app enable-all
		for d in $(echo "$optarg" | sed 's/,/ /g'); do
			app disable "$d"
		done
	;;
	--apps=*)
		app disable-all
		for d in $(echo "$optarg" | sed 's/,/ /g'); do
			app enable "$d"
		done
	;;
	--select-version=*)
		if [ -z "$versions" ]; then
			versions=$optarg
		else
			versions="$versions,$optarg"
		fi
	;;
	--cc=*) cc="$optarg"
	;;
	--ld=*) ld="$optarg"
	;;
	--prefix=*) prefix="$optarg"
	;;
	--destdir=*) DESTDIR="$optarg"
	;;
	--mod-name=*) MODNAME="$optarg"
	;;
	--disable-*)
		subsys disable "${opt#--disable-}"
	;;
	--enable-*)
		subsys enable "${opt#--enable-}"
	;;
	--cache=*) cache="$optarg"
	;;
	--help | -h)
		print_help
		exit
	;;
	--show-drivers)
		drv print
		exit
	;;
	--show-ext-drivers)
		edrv print
		exit
	;;
	--show-apps)
		app print
		exit
	;;
	--force-debug)
		DEBUG=1
	;;
	--no-force-debug)
		DEBUG=
	;;
	--no-utils)
		UTILS=
		;;
	--fail-on-driver-errors)
		DRVERRFAIL=1
		;;
	--without-dmasync)
		DMASYNC=
		;;
	*)
		echo "Unrecognized option: $opt" | warning
	;;
	esac
done

# update the divers subsets so that they are all consistent
update_drivers

####################################################################
################### START OF PROCESSING ############################
####################################################################

rm -f config.log
{
	echo "# netmap configure log $(date)"
	echo "# Configured with:"
	printf " '%s'" "$0" "$@"
	echo
	echo "#"
} > config.log

exec 2>> config.log

cp pre-commit .git/hooks

appl_arch=$($cc -dumpmachine | cut -d '-' -f 1)
if [ $appl_arch != "x86_64" ]; then
    # dedup uses inline x86_64 assembly
    app disable dedup
fi

################################
# check for sane configuration
################################

[ -n "$kernelver" ] || {
	kernelver="$(uname -r)"
}

[ -n "$ksrc" ] || {
	# user did not provide a kernel dir,
	# we try to find one by ourselves
	ksrc="/lib/modules/${kernelver}/build"
}

[ -n "$src" ] || {
	# user did not provide the path for the full kernel sources
	# we try to find one by ourselves
	[ -d "$ksrc/source" ] && src="$ksrc/source"
	[ -n "$src" ] || src=$ksrc
}

if [ ! -d "$ksrc" ]; then
	error <<EOF
Cannot find kernel directory.

We need at least the kernel headers to compile the netmap kernel module.
If your kernel headers are not in the standard place, please provide the
correct path using the

    --kernel-dir=/path/to/kernel/dir

option.

Otherwise, check that the 'build' symlink in

    /lib/modules/\$(uname -r)

is not broken.
EOF
fi
ksrc=$(cd $ksrc; pwd)

# check that ksrc has been prepared for external modules compilation
# It should contain a version.h file (in one of two possible places,
# depending on kernel version, and a .config file)
version_hdr="$ksrc/include/generated/uapi/linux/version.h"
[ -f "$version_hdr" ] || version_hdr="$ksrc/include/linux/version.h"
if [ ! -f "$ksrc/.config" ] || [ ! -f "$version_hdr" ]; then
	error <<EOF
kernel not configured.

The kernel directory must be ready for external module compilation.
You may need to issue the following or equivalent commands:

    cd $ksrc
    make oldconfig
    make modules_prepare
EOF
fi
lin_ver=$(awk '/LINUX_VERSION_CODE/ { printf "%03x%02x", $3/256, $3%256}' "$version_hdr")

# create the versions file
rm -f extdrv-versions.mak
for dv in $(echo "$versions" | sed 's/,/ /g'); do
	d=${dv%:*}
	v=${dv#*:}
	if ! $(edrv enabled $d); then
		echo "$d is not an external driver" | warning
	fi
	echo "$d@v := $v" >> extdrv-versions.mak
done

replace_vars $SRCDIR/default-config.mak.in_ > default-config.mak

###############################################################
# Makefile creation
###############################################################

# here we select the patches for the drivers and create the
# main Makefile. The Makefile is obtained from Makefile.in
# with some values replaced in (mainly the kernel directory).
# The final Makefile will include drivers.mak, which is also
# created here. drivers.mak will contain a <driver>@src
# and <driver>@patch variable each of the available drivers.

mod_list=
if ! drv is-empty; then
	[ -d patches ] || { rm -f patches; ln -s $SRCDIR/final-patches patches; }
fi

ln -s $SRCDIR/read-vars.mak 2>/dev/null || true
rm -f drivers.mak
# read in all the kernel .config, we use it below
. $ksrc/.config
# check for full kernel sources just once
src_checked=
src_found=
# cache
e_drivers=$(edrv print)
for d in $(drv print); do
	# reset all driver variables to default values
	drv_fetch=
	drv_src=
	drv_patch=
	drv_build=
	drv_distclean=
	drv_conf="CONFIG_$(basename $d .c | tr a-z- A-Z_)"
	# possibly override from config.mak
	eval $(make -snrf read-vars.mak $d@vars E_DRIVERS="$e_drivers")

	# check that the original driver had been compiled as a module, otherwise
	# skip this driver
	# (we do this mainly to be sure that any module dependency has already
	#  been taken care of)
	if [ -z "$drv_force" ]; then
		m="$(eval echo \$$drv_conf)"
		[ -n "$m" ] || {
			echo "$drv_conf not set in $ksrc/.config, skipping $d" | warning
			drv disable $d
			continue
		}
	fi
	[ "$m" = y ] && [ -z "$drvsuffix" ] && {
		warning <<EOF
The $d driver is not compiled as a module:
you will not be able to load the netmap enabled driver on this kernel.
Please consider setting

    $drv_conf=m

in your .config.

Alternatively, you can pass a --driver-suffix= option to configure.
EOF
	}

	if [ -n "$drv_fetch" ]; then
		message " NOTE  " <<EOF
We are trying to download the original sources for driver
$d using the following command:

  $drv_fetch

If this fails, please download the above file and put it
in $SRCDIR/ext-drivers/, then run configure again.
EOF
		eval $drv_fetch 2>&1 || { drverror <<EOF
Unable to fetch the sources for driver $d. Disabling driver.
EOF
			drv disable $d
			continue
		}
	fi

	if [ -z "$drv_src" ]; then
		# if the user has asked for the patched drivers, we also need the
		# full kernel sources. Since we may have put $src=$ksrc, and $ksrc
		# may only contain header files, we check that $src/drivers actually
		# contains some .c file
		if [ -z "$src_checked" ]; then
			if [ ! -d "$src" ] || [ -z "$(find "$src/drivers" -name '*.c' -print -quit)" ]; then {
				cat <<EOF
Cannot find full kernel sources.

Please note that most distributions provide separate packages for kernel
headers and sources. Once you know the path to kernel sources, you can
rerun this script with the additional

    --kernel-sources=/path/to/sources

option.

Native drivers that are listed as disabled below are not going to be built.
EOF
				if subsys enabled generic; then
					cat <<EOF
The corresponding devices will be accessed using a generic driver at
reduced performance.
EOF
				else
					cat <<EOF
Since the generic driver has been disabled, the corresponding NICs
will NOT be usable by netmap.
EOF
				fi
			} | warning
			else
				src=$(cd $src; pwd)
				src_found=1
			fi
			src_checked=1
		fi
		drv_kernel_src=
		if [ -n "$src_found" ]; then
			drv_kernel_src=$(find $src/drivers/ -name "$d" -print -quit)
		fi
		if [ -z "$drv_kernel_src" ]; then
			drverror <<EOF
'$d': sources not found.  Disabling driver.
EOF
			drv disable $d
			continue
		fi
		drv_src="cp -Rp $drv_kernel_src $d"
	fi

	if [ -z "$drv_patch" ]; then
		# check that we have a patch for this driver
		# XXX the selection is based only on the kernel version
		drv_patch=$(ls patches/vanilla--$d--* | awk -v v=$lin_ver -F -- '($3 != "*") && ($3 <= v"") && (v"" < $4)')
		if [ -z "$drv_patch" ]; then
			drverror <<EOF
'$d': no applicable patch found and no override provided.
Disabling driver.
EOF
			drv disable $d
			continue
		fi
	elif [ "$drv_patch" = none ]; then
		drv_patch=
	fi

	# if no external build command has been specified, add
	# this driver to the list of modules built by netmap,
	if [ -z "$drv_build" ]; then
		mod_list="$drv_conf=m $mod_list"
	fi

	# add the driver related variables to drivers.mak
	cat >> drivers.mak <<EOF
$d@conf := $drv_conf
$d@src := $drv_src
$d@patch := $(echo $drv_patch)
EOF
done

# update the subsets again since the above checks
# may have disabled some driver
update_drivers

#################################################
# preliminary build tests
#################################################

reset_tests

broken_buildsystem() {
	error <<EOF
It looks like we are not able to build kernel modules for the current
configuration. Please check 'config.log' for possible clues.
EOF
}

  add_test true broken_buildsystem < /dev/null

DISABLED_WARNINGS="unused-but-set-variable attributes packed-not-aligned \
	stringop-truncation missing-attributes format-truncation \
	maybe-uninitialized unused-variable unused-label"
REC_DISABLED_WARNINGS=
disable_warning() {
	REC_DISABLED_WARNINGS="$1 $REC_DISABLED_WARNINGS"
}

i=1
for w in $DISABLED_WARNINGS; do
	add_named_test "__warn__$i" "disable_warning $w" < /dev/null
	echo "CFLAGS___warn__$i.o = -Wno-error=$w" >> $TMPDIR/extra.mk
	i=$(($i+1))
done

  message " NOTE  " <<EOF
Running some preliminary tests to customize the build environment.
EOF
run_preliminary_tests

#################################################
# create the config.h file
#################################################

reset_tests

rm -f netmap_linux_config.h
if [ -e "$SRCDIR/netmap_linux_config.h" ]; then
	error <<EOF
The '$SRCDIR' directory appears to contain leftovers from a previous
compilation. This may break compilation in the current directory.
Please run 'make distclean' in '$SRCDIR', or start from a clean
repository if that fails.
EOF
fi

if [ -d "$cache" ] && [ -f "$cache/netmap_linux_config.h" ]; then
	cp "$cache/netmap_linux_config.h" .
else

  # BEGIN_TESTS
  # check that we can actually find the sources for each
  # configured driver
  drv_source_error()
  {
	drverror <<EOF
There were problems copying the sources of driver $1.

If you need this driver, please check that the $1@src variable
points to the correct path containing the driver sources.

Disabling $1.
EOF
	drv disable $1
	edrv disable $1
  }

  for d in $(drv print); do
	add_file_exists_check get-$d true "drv_source_error $d"
  done

  # check that we can build the unpatched external drivers
  edrv_build_error()
  {
	drverror <<EOF
There were problems building the external driver $1.

Please note that this is not related to the netmap patches,
that were not applied.

Disabling $1.
EOF
	drv disable $1
	edrv disable $1
  }

  for d in $(edrv print); do
	if !(cdrv enabled $d); then
            add_file_exists_check build-$d true "edrv_build_error $d"
	fi
  done

  # check that we can patch the internal drivers
  drv_patch_error()
  {
	drverror <<EOF
There were problems patching the driver $1.

Disabling $1.
EOF
	drv disable $1
  }

  for d in $(drv print); do
	  edrv enabled $d && continue
	  add_file_exists_check patch-$d true "drv_patch_error $d"
  done

  # ax25_ptr
  add_test 'have AX25PTR' <<EOF
	#include <linux/netdevice.h>

	void * dummy(struct net_device *dev)
	{
		return dev->ax25_ptr;
	}
EOF

  # iommu support
  add_test 'have IOMMU' <<EOF
	#include <linux/iommu.h>

	void dummy(void)
	{
	        struct iommu_group *grp = iommu_group_get(NULL);
	        int id = iommu_group_id(grp);

	        (void)grp;
	        (void)id;
	}
EOF

  # return value of hrtimer handler
  add_test 'define TIMER_RTYPE "enum hrtimer_restart"' 'define TIMER_RTYPE int' <<EOF
	#include <linux/hrtimer.h>

	enum hrtimer_restart
	testmod_timer_handler(struct hrtimer *t)
	{
	        (void)t;
	        return HRTIMER_RESTART;
	}
EOF

  # rx_register (intercept packets in the generic adapter)
  add_test 'have RX_REGISTER' <<EOF
	#include <linux/netdevice.h>

	int dummy(void)
	{
	        return netdev_rx_handler_register(NULL, NULL, NULL);
	}
EOF

  # rx_handler_result_t
  add_test 'have RX_HANDLER_RESULT' <<EOF
	#include <linux/netdevice.h>


	static rx_handler_result_t dummy_rx_handler(struct sk_buff **pm)
	{
	        (void)pm;
	        return RX_HANDLER_PASS;
	}

	int dummy(void)
	{
	        return netdev_rx_handler_register(NULL, dummy_rx_handler, NULL);
	}
EOF

  # (un)use_mm is unavailable in kernel 5.8 and later
  add_test 'have KTHREAD_USE_MM' <<EOF
	#include <linux/kthread.h>
	#include <linux/mmu_context.h>

	void dummy(struct mm_struct *mm)
	{
		kthread_use_mm(mm);
	}
EOF

  # number of parameters in ndo_select_queue
  # (we expect at most one of these to succeed)
  params="NULL, NULL"
  for n in 2 3 4; do
  	add_test "define SELECT_QUEUE $n" <<EOF
  		#include <linux/netdevice.h>

  		u16 dummy(struct net_device_ops *ndo)
  		{
  		        return ndo->ndo_select_queue($params);
  		}
EOF
	params="NULL, $params"
  done

  # type of the 3rd param of ndo_select_queue
  # defaults to void* if not defined
  add_test 'define SELECT_QUEUE_PARM3 "struct net_device*"' <<EOF
	#include <linux/netdevice.h>

	static u16 myselect(struct net_device *dev, struct sk_buff *skb,
		struct net_device *sb_dev, select_queue_fallback_t fallback)
	{
		(void)dev;
		(void)skb;
		(void)sb_dev;
		(void)fallback;
		return 0;
	}
	struct net_device_ops ndo = {
		.ndo_select_queue = myselect,
	};
EOF

  # type of the 3rd param of ndo_select_queue
  # defaults to void* if not defined
  add_test 'define SELECT_QUEUE_PARM3 "struct net_device*"' <<EOF
	#include <linux/netdevice.h>

	static u16 myselect(struct net_device *dev, struct sk_buff *skb,
		struct net_device *sb_dev)
	{
		(void)dev;
		(void)skb;
		(void)sb_dev;
		return 0;
	}
	struct net_device_ops ndo = {
		.ndo_select_queue = myselect,
	};
EOF

  # ethtool get_ringparam
  add_test 'have GET_RINGPARAM' <<EOF
	#include <linux/netdevice.h>
	#include <linux/ethtool.h>

	void
	dummy(struct net_device *net, struct ethtool_ringparam *rp) {
	        net->ethtool_ops->get_ringparam(net, rp);
	}
EOF

  # ethtool set/get_channels
  add_test 'have SET_CHANNELS' <<EOF
	#include <linux/netdevice.h>
	#include <linux/ethtool.h>

	int
	dummy(struct net_device *net, struct ethtool_channels *c) {
		net->ethtool_ops->get_channels(net, c);
		return net->ethtool_ops->set_channels(net, c);
	}
EOF

  # pernet_operations id field
  add_test 'have PERNET_OPS_ID' <<EOF
	#include <net/net_namespace.h>

	int *
	dummy(struct pernet_operations *ops) {
		return ops->id;
	}
EOF

  # check for real_num_rx_queues
  add_test 'have REAL_NUM_RX_QUEUES' <<EOF
	#include <linux/netdevice.h>

	unsigned int
	dummy(struct net_device *net)
	{
	    return net->real_num_rx_queues;
	}
EOF

  # check for num_rx_queues
  add_test 'have NUM_RX_QUEUES' <<EOF
	#include <linux/netdevice.h>

	unsigned int
	dummy(struct net_device *net)
	{
	    return net->num_rx_queues;
	}
EOF

  # check for netif_set_real_num_rx_queues
  add_test 'have SET_REAL_NUM_TX_QUEUES' <<EOF
	#include <linux/netdevice.h>

	int
	dummy(struct net_device *net, unsigned int txq)
	{
	    return netif_set_real_num_tx_queues(net, txq);
	}
EOF

  # poll_table key field
  for k in _key key; do
	add_test "define PWAIT_KEY $k" <<EOF
		#include <linux/poll.h>

		int
		dummy(struct poll_table_struct *pwait)
		{
		        return pwait->$k;
		}
EOF
  done

  # check for unlocked_ioctl
  add_test 'have UNLOCKED_IOCTL' <<EOF
	#include <linux/fs.h>

	void *
	dummy(struct file_operations *fops)
	{
	        return fops->unlocked_ioctl;
	}
EOF

  # check for init_net
  add_test 'have INIT_NET' <<EOF
	#include <linux/netdevice.h>

	struct net_device *
	dummy(const char *name)
	{
	        return dev_get_by_name(&init_net, name);
	}
EOF

  # check for skb_copy_to_linear_data*
  add_test 'have SKB_COPY_LINEAR' <<EOF
	#include <linux/skbuff.h>

	void dummy(struct sk_buff *skb, const void *from, const unsigned int len)
	{
	        skb_copy_to_linear_data(skb, from, len);
	}
EOF

  # check for uintptr_t
  add_test 'have UINTPTR' <<EOF
	uintptr_t dummy;
EOF

  # check for queue_mapping
  add_test 'have QUEUE_MAPPING' <<EOF
	#include <linux/skbuff.h>

	u16 dummy(const struct sk_buff *skb)
	{
	        return skb_get_queue_mapping(skb);
	}
EOF

  # check for hrtimer_forward_now
  add_test 'have HRTIMER_FORWARD_NOW' <<EOF
	#include <linux/hrtimer.h>

	u64 dummy(struct hrtimer *timer, ktime_t interval)
	{
	        return hrtimer_forward_now(timer, interval);
	}
EOF

  # check for phys_addr_t
  add_test 'have PHYS_ADDR_T' <<EOF
	#include <linux/types.h>

	phys_addr_t dummy;
EOF

  # check for net_device_ops
  add_test 'have NETDEV_OPS' <<EOF
	#include <linux/netdevice.h>

	struct net_device_ops dummy;
EOF

  # check for netdev_tx_t
  add_test 'have NETDEV_TX_T' <<EOF
	#include <linux/netdevice.h>

	netdev_tx_t dummy;
EOF

  # check for usleep_range
  add_test 'have USLEEP_RANGE' <<EOF
	#include <linux/delay.h>

	void dummy(void)
	{
	        usleep_range(0, 0);
	}
EOF

  # check for HRTIMER_MODE_REL
  add_test 'have HRTIMER_MODE_REL' <<EOF
	#include <linux/hrtimer.h>

	void dummy(struct hrtimer *timer, clockid_t which_clock)
	{
	        hrtimer_init(timer, which_clock, HRTIMER_MODE_REL);
	}
EOF

  # check for IFF_LIVE_ADDR_CHANGE
  add_test 'have LIVE_ADDR_CHANGE' <<EOF
	#include <linux/netdevice.h>

	int dummy = IFF_LIVE_ADDR_CHANGE;
EOF

  # check for ndo_get_stats64
  add_test 'have GET_STATS64' <<EOF
	#include <linux/netdevice.h>

	void * dummy(struct net_device_ops *ops) {
	       return ops->ndo_get_stats64;
	}
EOF

  # check for IFF_TX_SKB_SHARING
  add_test 'have TX_SKB_SHARING' <<EOF
	#include <linux/netdevice.h>

	int dummy = IFF_TX_SKB_SHARING;
EOF

  # check for hw_features in net_device
  add_test 'have HW_FEATURES' <<EOF
	#include <linux/netdevice.h>

	unsigned int dummy(struct net_device *n) {
		return n->hw_features;
	}
EOF

  # check for eth_hw_addr_random
  add_test 'have ADDR_RANDOM' <<EOF
	#include <linux/etherdevice.h>

	void dummy(struct net_device *dev) {
	        eth_hw_addr_random(dev);
	}
EOF

  # arguments of alloc_netdev (either 4 or 3)
  add_test 'define ALLOC_NETDEV_4ARGS' <<EOF
	#include <linux/netdevice.h>

	struct net_device *
	dummy(int sizeof_priv, const char *name,
		unsigned char name_assign_type,
		void (*setup)(struct net_device *))
	{
		return alloc_netdev(sizeof_priv, name,
			name_assign_type, setup);
	}
EOF

  # netdev_notifier_info_to_dev
  add_test 'have NNITD' <<EOF
	#include <linux/netdevice.h>

	struct net_device *
	dummy(void *ptr)
	{
		return netdev_notifier_info_to_dev(ptr);
	}
EOF

  # first argument of sock_create_kern() is a 'struct net*'
  add_test 'define SOCK_CREATE_KERN_NETNS' <<EOF
	#include <net/sock.h>

	int
	dummy(void)
	{
		struct net *net = NULL;
		return sock_create_kern(net, 0, 0, 0, NULL);
	}
EOF

  # check for napi_complete_done
  add_test 'have NAPI_COMPLETE_DONE' <<EOF
	#include <linux/netdevice.h>

	void dummy(struct napi_struct *n, int work_done) {
		napi_complete_done(n, work_done);
	}
EOF

  # check for napi_alloc_skb
  add_test 'have NAPI_ALLOC_SKB' <<EOF
	#include <linux/skbuff.h>

	struct sk_buff *
	dummy(struct napi_struct *n, unsigned int l) {
		return napi_alloc_skb(n, l);
	}
EOF

  # check for netdev_alloc_skb_ip_align
  add_test 'have ALLOC_SKB_IP_ALIGN' <<EOF
	#include <linux/skbuff.h>

	struct sk_buff *
	dummy(struct net_device *n, unsigned int l) {
		return netdev_alloc_skb_ip_align(n, l);
	}
EOF

  # check for xmit_more in sk_buff
  add_test 'have XMIT_MORE' <<EOF
	#include <linux/skbuff.h>

	unsigned int
	dummy(struct sk_buff *skb) {
		return skb->xmit_more;
	}
EOF

  # arguments of skb_add_rx_frag (either 5 or 6)
  add_test 'define SKB_ADD_RX_FRAG_6ARGS' <<EOF
	#include <linux/skbuff.h>

	void
	dummy(struct sk_buff *skb, int i, struct page *p,
	      int off, int size, int truesize)
	{
		skb_add_rx_frag(skb, i, p, off, size, truesize);
	}
EOF

  # check for skb_frag_size
  add_test 'have SKB_FRAG_SIZE' <<EOF
	#include <linux/skbuff.h>

	unsigned int
	dummy(const skb_frag_t *frag) {
		return skb_frag_size(frag);
	}
EOF

  # check for skb_frag_address
  add_test 'have SKB_FRAG_ADDRESS' <<EOF
	#include <linux/skbuff.h>

	void *
	dummy(const skb_frag_t *frag) {
		return skb_frag_address(frag);
	}
EOF

  # check for skb_checksum_start_offset
  add_test 'have SKB_CHECKSUM_START_OFFSET' <<EOF
	#include <linux/skbuff.h>

	int
	dummy(const struct sk_buff *skb) {
		return skb_checksum_start_offset(skb);
	}
EOF

  # page_ref?
  add_test 'have PAGE_REF' <<EOF
  	#include <linux/page_ref.h>
EOF

  # _count or _refcount?
  for f in _count _refcount; do
	  add_test "define PAGE_COUNT $f" <<EOF
	  #include <linux/mm.h>

	  atomic_t
	  dummy(struct page *page) {
	  	return page->$f;
	  }
EOF
  done

# check for third argument in qdisc enqueue callbacks
  add_test 'have QDISC_ENQUEUE_TOFREE' <<EOF
	#include <net/sch_generic.h>

	int
	dummy(struct sk_buff *skb, struct Qdisc *q, struct sk_buff **to_free) {
		return q->enqueue(skb, q, to_free);
	}
EOF

# check for redhat register_netdevice_notifier_rh
  add_test 'have REG_NOTIF_RH' <<EOF
	#include <linux/netdevice.h>

	int
	dummy(struct notifier_block *nb) {
		return register_netdevice_notifier_rh(nb);
	}
EOF

# check for redhat ndo_change_mtu_rh74
  add_test 'define CHANGE_MTU ndo_change_mtu_rh74' 'define CHANGE_MTU ndo_change_mtu' <<EOF
	#include <linux/netdevice.h>

	int
	dummy(struct net_device_ops *ops, struct net_device *dev) {
		return ops->ndo_change_mtu_rh74(dev, 0);
	}
EOF

# check for fault arguments
  add_test 'have FAULT_VMA_ARG' <<EOF
        #include <linux/mm.h>

	int
	dummy(struct vm_operations_struct *ops,
		struct vm_area_struct *vma, struct vm_fault *vmf) {
		return ops->fault(vma, vmf);
	}
EOF

# check for sched/mm.h
  add_test 'have SCHED_MM' <<EOF
  #include <linux/sched/mm.h>

  void dummy(void) {}
EOF

# check for void get_stats64
  add_test 'have NONVOID_GET_STATS64' <<EOF
  	#include <linux/netdevice.h>

  	struct rtnl_link_stats64 *
  	dummy(struct net_device_ops *ops, struct net_device *dev,
		struct rtnl_link_stats64 *storage)
	{
		return ops->ndo_get_stats64(dev, storage);
	}
EOF

# check for net_dev destructor
  add_test 'have NETDEV_DTOR' <<EOF
  	#include <linux/netdevice.h>

	void
	dummy(struct net_device *dev)
	{
		return dev->destructor(dev);
	}
EOF

# wait_queue_t or wait_queue_entry_t ?
  add_test 'have WAIT_QUEUE_ENTRY_T' <<EOF
	#include <linux/wait.h>

	void *
	dummy(wait_queue_entry_t *wq) {
		return wq->private;
	}
EOF

# pci_enable_msix or pci_alloc_irq_vectors ?
  add_test 'have PCI_ENABLE_MSIX' <<EOF
	#include <linux/pci.h>

	int
	dummy(struct pci_dev *dev, struct msix_entry *entries, int nvec) {
		return pci_enable_msix(dev, entries, nvec);
	}
EOF

  # are skb->users and qdisc->refcnt atomic_t or refcount_t ?
  add_test 'have REFCOUNT_T' <<EOF
	#include <linux/skbuff.h>

	unsigned int
	dummy(void) {
                struct sk_buff *skb = NULL;
                return refcount_read(&skb->users);
	}
EOF

  # kernels from 4.14 onwards don't have support for UDP fragmentation
  # offload.
  add_test 'have UFO' <<EOF
	#include <linux/netdevice.h>

	unsigned int
	dummy(void) {
                return NETIF_F_UFO;
	}
EOF

# check for get_user_pages_unlocked number of args
  add_test 'have GUP_4ARGS' <<EOF
  	#include <linux/mm.h>

	long
	dummy(unsigned long start, unsigned long nr_pages,
		struct page **pages, unsigned int gup_flags) {
		return get_user_pages_unlocked(start, nr_pages, pages, gup_flags);
	}
EOF

  add_test 'have GUP_5ARGS' <<EOF
  	#include <linux/mm.h>

	long
	dummy(unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages) {
		return get_user_pages_unlocked(start, nr_pages, write, force, pages);
	}
EOF

  add_test 'have GUP_7ARGS' <<EOF
  	#include <linux/mm.h>

	long
	dummy(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages) {
		return get_user_pages_unlocked(tsk, mm, start, nr_pages,
			write, force, pages);
	}
EOF

  add_test 'have PIN_PAGES' <<EOF
	#include <linux/mm.h>

	long
	dummy(unsigned long start, unsigned long nr_pages,
		unsigned int gup_flags, struct page **pages) {
		return pin_user_pages_unlocked(start, nr_pages, pages, gup_flags);
	}
EOF

  add_test 'have FOLL_SPLIT' <<EOF
	#include <linux/mm.h>

	int
	dummy(void) {
		return FOLL_SPLIT;
	}
EOF

# check for page_to_virt
  add_test 'have PAGE_TO_VIRT' <<EOF
  	#include <linux/mm.h>

	void *
	dummy(struct page *page) {
		return page_to_virt(page);
	}
EOF

# check for extack in Qdisc_ops init callback
  add_test 'have QDISC_EXTACK' <<EOF
  	#include <net/sch_generic.h>

	int
	dummy(struct Qdisc_ops *ops, struct netlink_ext_ack *extack) {
		return ops->init(NULL, NULL, extack);
	}
EOF

# check for <linux/average.h>
  add_test 'have AVERAGE_H' <<EOF
	#include <linux/average.h>

	DECLARE_EWMA(myname, 1, 64);
	void
	dummy(struct ewma_myname *x) {
		ewma_myname_add(x, 18);
	}
EOF

# check for ethtool_validate_speed() and ethtool_validate_duplex()
  add_test 'have ETHTOOL_VALIDATE' <<EOF
	#include <linux/ethtool.h>

	int
	dummy(void) {
		return ethtool_validate_speed(0) + ethtool_validate_duplex(0);
	}
EOF

  add_test 'have U64_STATS_IRQ' <<EOF
	#include <linux/u64_stats_sync.h>

	unsigned int
	dummy(const struct u64_stats_sync *x) {
		return u64_stats_fetch_begin_irq(x);
	}
EOF

  # is struct timeval defined?
  add_test 'have STRUCT_TIMEVAL' << EOF
	#include <linux/time.h>

	void
	dummy(struct timeval *tv) {
		tv->tv_sec = 0;
		tv->tv_usec = 0;
		return;
	}
EOF

  add_test 'have DO_GETTIMEOFDAY' <<EOF
	#include <linux/time.h>

	void
	dummy(struct timeval *tv) {
		do_gettimeofday(tv);
	}
EOF

   # is vm_fault_t defined?
   add_test 'have VMFAULT_T' <<EOF
	#include <linux/mm.h>

	vm_fault_t dummy(void) {
		return 0;
	}
EOF

  # nf_reset() or nf_reset_ct()?
  add_test 'have NF_RESET_CT' <<EOF
	#include <linux/skbuff.h>

	void dummy(struct sk_buff *skb) {
		nf_reset_ct(skb);
	}
EOF

  #####################################################
  # checks related to drivers                         #
  #####################################################

  # e1000e
  if drv enabled e1000e; then

  add_file_exists_check e1000e/e1000.h true "drv_source_error e1000e"

  add_test 'have E1000E_HWADDR' <<EOF
  	#include "e1000e/e1000.h"

  	void* dummy(struct e1000_adapter *adapter,
  	        struct e1000_ring *ring)
  	{
  		return adapter->hw.hw_addr + ring->tail;
  	}
EOF

  add_test 'have E1000E_DOWN2' <<EOF
  	#include "e1000e/e1000.h"

  	void dummy(struct e1000_adapter *adapter)
  	{
  		e1000e_down(adapter, false);
  	}
EOF

  add_test "grep -q '\<e1000_rx_desc_extended\>' $TMPDIR/e1000e/netdev.c \
  	&& have E1000E_EXT_RXDESC" </dev/null
  fi # e1000e

  # rtl8169
  if drv enabled r8169.c; then

  add_file_exists_check r8169.c true "drv_source_error r8169.c"

  add_test 'define RTL_OPEN rtl8169_open' 'define RTL_OPEN rtl_open' <<EOF
  	#include "r8169.c"

  	static int dummy(struct net_device *dev) {
  		return rtl8169_open(dev);
  	}
EOF

  add_test 'have RTL_WFQ' <<EOF
  	#include "r8169.c"

  	static void dummy(struct net_device *dev) {
  		rtl8169_wait_for_quiescence(dev);
  	}
EOF
  fi # r8169.c

  # ixgbe
  if drv enabled ixgbe; then

  add_file_exists_check ixgbe/ixgbe.h true "drv_source_error ixgbe"

  # different versions of IXGBE_?X_DESC
  add_test 'define IXGBE_DESC 1' <<EOF
  	#include "ixgbe/ixgbe.h"

  	union ixgbe_adv_tx_desc *
  	dummy(struct ixgbe_ring *ring) {
  		return IXGBE_TX_DESC_ADV(*ring, 0);
  	}
EOF
  add_test 'define IXGBE_DESC 2' <<EOF
  	#include "ixgbe/ixgbe.h"

  	union ixgbe_adv_tx_desc *
  	dummy(struct ixgbe_ring *ring) {
  		return IXGBE_TX_DESC_ADV(ring, 0);
  	}
EOF
  add_test 'define IXGBE_DESC 3' <<EOF
  	#include "ixgbe/ixgbe.h"

  	union ixgbe_adv_tx_desc *
  	dummy(struct ixgbe_ring *ring) {
  		return IXGBE_TX_DESC(ring, 0);
  	}
EOF

  # array of rings or array of poiners to rings?
  add_test 'define IXGBE_PTR_ARRAY' <<EOF
  	#include "ixgbe/ixgbe.h"

  	struct ixgbe_ring *
  	dummy(struct ixgbe_adapter *adapter) {
  		return adapter->tx_ring[0];
  	}
EOF

  # is ixgbe_irq_disable_queues available?
  add_test "define IXGBE_HAVE_DISABLE" <<EOF
 	 #include "ixgbe/ixgbe_main.c"

 	 void
 	 dummy(struct ixgbe_adapter *adapter, u64 qmask) {
 	 	ixgbe_irq_disable_queues(adapter, qmask);
 	 }
EOF

  # is next_to_alloc defined?
  add_test "define IXGBE_HAVE_NTA" <<EOF
  	#include "ixgbe/ixgbe.h"

	u16
	dummy(struct ixgbe_ring *ring) {
		return ring->next_to_alloc;
	}
EOF

    add_test 'have IXGBE_RX_BUFSZ' <<EOF
       #include "ixgbe/ixgbe.h"

       unsigned int
       dummy(struct ixgbe_ring *ring) {
               return ixgbe_rx_bufsz(ring);
       }
EOF

  fi # ixgbe

  if drv enabled ixgbevf; then

  add_file_exists_check ixgbevf/ixgbevf.h true "drv_source_error ixgbevf"

  # IXGBEVF_* or IXGBE_*?
  add_test true 'define IXGBEVF_IXGBE_MACROS' <<EOF
  	#include "ixgbevf/ixgbevf.h"

	void *
	dummy(struct ixgbevf_ring *ring, unsigned int i)
	{
		return IXGBEVF_RX_DESC(ring, i);
	}
EOF

  # array of rings or array of poiners to rings?
  add_test 'define IXGBEVF_PTR_ARRAY' <<EOF
  	#include "ixgbevf/ixgbevf.h"

  	struct ixgbevf_ring *
  	dummy(struct ixgbevf_adapter *adapter) {
  		return adapter->tx_ring[0];
  	}
EOF
  # is next_to_alloc defined?
  add_test "define IXGBEVF_HAVE_NTA" <<EOF
  	#include "ixgbevf/ixgbevf.h"

	u16
	dummy(struct ixgbevf_ring *ring) {
		return ring->next_to_alloc;
	}
EOF
  fi

  if drv enabled virtio_net.c; then

    VNETDIR=""
    if edrv enabled virtio_net.c; then
        VNETDIR="virtio_net.c/"
    fi

    add_file_exists_check ${VNETDIR}virtio_net.c true "drv_source_error virtio_net.c"

    add_test 'define VIRTIO_NET_HDR_FROM_SKB_5ARGS' <<EOF
	#include <linux/virtio_net.h>

	int
	dummy(const struct sk_buff *skb, struct virtio_net_hdr *hdr,
		bool little_endian, bool has_data_valid, int vlan_hlen) {
		return virtio_net_hdr_from_skb(skb, hdr, little_endian,
					has_data_valid, vlan_hlen);
	}
EOF

    add_test 'define VIRTIO_NET_HDR_FROM_SKB_4ARGS' <<EOF
	#include <linux/virtio_net.h>

	int
	dummy(const struct sk_buff *skb, struct virtio_net_hdr *hdr,
		bool little_endian, bool has_data_valid) {
		return virtio_net_hdr_from_skb(skb, hdr, little_endian,
					has_data_valid);
	}
EOF

    add_test 'define VIRTIO_NET_HDR_FROM_SKB_3ARGS' <<EOF
	#include <linux/virtio_net.h>

	int
	dummy(const struct sk_buff *skb, struct virtio_net_hdr *hdr,
		bool little_endian) {
		return virtio_net_hdr_from_skb(skb, hdr, little_endian);
	}
EOF

  add_test 'have FIND_VQS_CTX_ARG' <<EOF
	#include <linux/virtio_config.h>

	int
	dummy(struct virtio_config_ops *ops, const bool *ctx,
		struct irq_affinity *desc)
	{
		return ops->find_vqs(NULL, 0, NULL, NULL, NULL,
					ctx, desc);
	}
EOF

  add_test 'have FIND_VQS_IRQAFF_ARG' <<EOF
	#include <linux/virtio_config.h>

	int
	dummy(struct virtio_config_ops *ops, struct irq_affinity *desc)
	{
		return ops->find_vqs(NULL, 0, NULL, NULL, NULL,
					desc);
	}
EOF

  add_test 'have VIRTIO_BYTEORDER' <<EOF
	#include <linux/virtio_byteorder.h>

	u16
	dummy(bool little_endian, __virtio16 val)
	{
		return __virtio16_to_cpu(little_endian, val);
	}
EOF

  add_test 'have VIRTIO_IS_LITTLE_ENDIAN' <<EOF
	#include <linux/virtio_config.h>

	bool
	dummy(struct virtio_device *vdev)
	{
		return virtio_is_little_endian(vdev);
	}
EOF

  add_test 'have VIRTIO_MEMORY_ACCESSORS' <<EOF
	#include <linux/virtio_config.h>

	u16
	dummy(struct virtio_device *vdev)
	{
		return virtio16_to_cpu(vdev, 0);
	}
EOF

  add_test 'have VIRTIO_DRIVER_FEATURE_TABLE_LEGACY' <<EOF
	#include <linux/virtio.h>

	bool
	dummy(struct virtio_driver *vdr)
	{
		return vdr->feature_table_legacy != NULL;
	}
EOF

  add_test 'have VIRTIO_DEVICE_READY' <<EOF
	#include <linux/virtio_config.h>

	void
	dummy(struct virtio_device *vdev)
	{
		virtio_device_ready(vdev);
	}
EOF

  add_test 'have VIRTQUEUE_IS_BROKEN' <<EOF
	#include <linux/virtio.h>

	bool
	dummy(struct virtqueue *vq)
	{
		return virtqueue_is_broken(vq);
	}
EOF

  add_test 'have SKB_COALESCE_RX_FRAG' <<EOF
	#include <linux/skbuff.h>

	void
	dummy(struct sk_buff *skb, int i, int size,
		unsigned int truesize)
	{
		skb_coalesce_rx_frag(skb, i, size, truesize);
	}
EOF

  add_test 'have VIRTIO_CONFIG_ACCESSORS' <<EOF
	#include <linux/virtio_config.h>

	u16
	dummy(struct virtio_device *vdev, unsigned int offset)
	{
		return virtio_cread16(vdev, offset);
	}
EOF

  add_test 'have U64_STATS_INIT' <<EOF
	#include <linux/u64_stats_sync.h>

	void
	dummy(struct u64_stats_sync *syncp)
	{
		u64_stats_init(syncp);
	}
EOF

  add_test 'have NAPI_HASH_DEL' <<EOF
	#include <linux/netdevice.h>

	void
	dummy(struct napi_struct *napi)
	{
		napi_hash_del(napi);
	}
EOF

    add_test 'define VIRTIO_CB_DELAYED' <<EOF
  	#include <linux/virtio.h>

  	bool
  	dummy(struct virtqueue *vq) {
  		return virtqueue_enable_cb_delayed(vq);
  	}
EOF

    add_test 'define VIRTIO_GET_VRSIZE' <<EOF
  	#include <linux/virtio.h>

  	unsigned int
  	dummy(struct virtqueue *vq) {
  		return virtqueue_get_vring_size(vq);
  	}
EOF

    add_test 'define VIRTIO_FREE_PAGES' <<EOF
	#include "${VNETDIR}virtio_net.c"

  	void
  	dummy(struct virtnet_info *vi) {
  		free_receive_bufs(vi);
  	}
EOF

    add_test 'define VIRTIO_FUNCTIONS' <<EOF
  	#include <linux/virtio.h>

  	void
  	dummy(struct virtqueue *vq) {
  		(void)virtqueue_kick(vq);
  	}
EOF

    for s in "" _gfp; do
  	f="virtqueue_add_buf$s"
  	add_test "define VIRTIO_ADD_BUF $f" <<EOF
  		#include <linux/virtio.h>

  		int
  		dummy(struct virtqueue *vq, struct scatterlist sg[],
  			unsigned int out_num, unsigned int in_num,
  			void *data, gfp_t gfp)
  		{
  			return $f(vq, sg, out_num, in_num, data, gfp);
  		}
EOF
  done

    add_test 'define VIRTIO_MULTI_QUEUE' <<EOF
	#include "${VNETDIR}virtio_net.c"

  	struct virtqueue *
  	dummy(struct virtnet_info *vi) {
  		return vi->rq[0].vq;
  	}
EOF

    add_test 'define VIRTIO_RQ_NUM' <<EOF
	#include "${VNETDIR}virtio_net.c"

  	int
  	dummy(struct virtnet_info *vi) {
  		return vi->rq[0].num;
  	}
EOF

    add_test 'define VIRTIO_SG' <<EOF
	#include "${VNETDIR}virtio_net.c"

  	struct scatterlist *
  	dummy(struct virtnet_info *vi) {
  		return vi->rx_sg;
  	}
EOF

     add_test 'define VIRTIO_NOTIFY' <<EOF
  	#include <linux/virtio.h>

  	void
  	dummy(struct virtqueue *_vq) {
  		(void)virtqueue_notify(_vq);
  	}
EOF

     add_test 'have GET_LINK_KSETTINGS' <<EOF
	#include <linux/ethtool.h>

	int
	dummy(struct ethtool_ops *ops, struct ethtool_link_ksettings *l)
	{
		return ops->get_link_ksettings(NULL, l);
	}
EOF

  fi # virtio-net

  if drv enabled ice; then
    add_test 'define ICE_PTR_ARRAY' <<EOF
  	#include "ice/ice.h"

  	struct ice_ring *
  	dummy(struct ice_vsi *vsi) {
  		return vsi->tx_rings[0];
  	}
EOF

   add_test 'define ICE_PTR_STATE' <<EOF
   	#include "ice/ice.h"
	#include <linux/bitops.h>
	#pragma GCC diagnostic error "-Wincompatible-pointer-types"

	int
	dummy(struct ice_pf *pf) {
		return test_and_set_bit(1, &pf->state);
	}
EOF
  fi # ice

  if drv enabled i40e; then
    add_test 'define I40E_PTR_ARRAY' <<EOF
  	#include "i40e/i40e.h"

  	struct i40e_ring *
  	dummy(struct i40e_vsi *vsi) {
  		return vsi->tx_rings[0];
  	}
EOF

   add_test 'define I40E_PTR_STATE' <<EOF
   	#include "i40e/i40e.h"
	#include <linux/bitops.h>
	#pragma GCC diagnostic error "-Wincompatible-pointer-types"

	int
	dummy(struct i40e_pf *pf) {
		return test_and_set_bit(1, &pf->state);
	}
EOF
  fi # i40e

  if drv enabled igb; then
    add_test 'have IGB_RD32' <<EOF
        #include "igb/e1000_regs.h"

	u32
	dummy(struct e1000_hw *hw, u32 reg) {
		return igb_rd32(hw, reg);
	}
EOF

    add_test 'have IGB_NTA' <<EOF
       #include "igb/igb.h"

       unsigned int
       dummy(struct igb_ring *ring) {
		return ring->next_to_alloc;
       }
EOF
  fi # igb

  # END_TESTS

  # now we actually create the file

  rm -f $configh
  cat > $configh <<EOF
  	#ifndef NETMAP_LINUX_CONFIG_H
  	#define NETMAP_LINUX_CONFIG_H
EOF

  # the TESTPOSTPROC script will add macros to $configh
  message " NOTE  " <<EOF
Now running compile tests to adapt the code to your
kernel version. Please wait.
EOF
  run_tests

# check for exported split_page
  cat >> config.log <<EOF
##############################################################################
## CHECKING FOR split_page
##############################################################################
EOF
  symf=$ksrc/Module.symvers
  if [ -e $symf ]; then
	  if cut -f2 $symf | grep -q split_page; then
		  echo "found in $symf" >> config.log
		  have SPLIT_PAGE
	  else
		  echo "not found in $symf" >> config.log
	  fi
  else
	  echo "$symf file not found" >> config.log
  fi
  cat >> config.log <<EOF
##############################################################################
EOF

  if [ -n "$DMASYNC" ]; then
	  have DMASYNC
  fi

  define DRIVER_SUFFIX \"$drvsuffix\"

  # file end
  cat >> $configh <<EOF

  	#endif
EOF

  if [ -d "$cache" ]; then
  	cp $configh "$cache"
  fi

fi # ! -f $cache/netmap_config_h

# create netmap.mak and Kbuild
for f in $SRCDIR/*.in; do
	replace_vars $f > $(basename $f .in)
done

# if we are in SRCDIR this will fail, since
# Makefile already exists
ln -s $SRCDIR/../GNUmakefile || true
ln -s $SRCDIR/drv-subdir.mak || true



report

# create the build directory for libnetmap
mkdir -p build-libnetmap
ln -s $SRCDIR/../libnetmap/GNUmakefile build-libnetmap 2>/dev/null || true

# create the build directory for the examples
mkdir -p build-apps
for a in $(app print); do
	mkdir -p build-apps/$a
	ln -s $SRCDIR/../apps/$a/GNUmakefile build-apps/$a/GNUmakefile 2> /dev/null || true
done

# create the build directory for the utils
if [ -n "$UTILS" ]; then
	mkdir -p build-utils
	ln -s $SRCDIR/../utils/GNUmakefile build-utils/GNUmakefile 2>/dev/null || true
	ln -s $SRCDIR/../utils/tests 2>/dev/null || true
fi

# config.status can be used to rerun configure with the
# same arguments
rm -f config.status
{ printf " '%s'" "$0" "$@"; echo; } > config.status
chmod +x config.status
