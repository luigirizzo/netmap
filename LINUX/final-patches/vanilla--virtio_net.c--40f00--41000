diff --git a/virtio_net.c b/virtio_net.c
index 559b215c0169..00aad16f3aa2 100644
--- a/virtio_net.c
+++ b/virtio_net.c
@@ -181,6 +181,10 @@ struct virtnet_info {
 	unsigned long guest_offloads;
 };
 
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#include <virtio_netmap.h>
+#endif
+
 struct padded_vnet_hdr {
 	struct virtio_net_hdr_mrg_rxbuf hdr;
 	/*
@@ -274,6 +278,11 @@ static void skb_xmit_done(struct virtqueue *vq)
 	/* Suppress further interrupts. */
 	virtqueue_disable_cb(vq);
 
+#ifdef DEV_NETMAP
+        if (netmap_tx_irq(vi->dev, vq2txq(vq)))
+		return;
+#endif
+
 	if (napi->weight)
 		virtqueue_napi_schedule(napi, vq);
 	else
@@ -1205,6 +1214,19 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
 	unsigned int received;
 	bool xdp_xmit = false;
 
+#ifdef DEV_NETMAP
+        int work_done = 0;
+	struct virtnet_info *vi = rq->vq->vdev->priv;
+	int nm_irq = netmap_rx_irq(vi->dev, vq2rxq(rq->vq), &work_done);
+
+	if (nm_irq == NM_IRQ_COMPLETED) {
+		napi_complete(napi);
+                return 1;
+        } else if (nm_irq == NM_IRQ_RESCHED) {
+		return budget;
+	}
+#endif
+
 	virtnet_poll_cleantx(rq);
 
 	received = virtnet_receive(rq, budget, &xdp_xmit);
@@ -1223,6 +1245,15 @@ static int virtnet_open(struct net_device *dev)
 {
 	struct virtnet_info *vi = netdev_priv(dev);
 	int i;
+#ifdef DEV_NETMAP
+        int ok = virtio_netmap_init_buffers(vi);
+
+        if (ok) {
+            for (i = 0; i < vi->max_queue_pairs; i++)
+		virtnet_napi_enable(vi->rq[i].vq, &vi->rq[i].napi);
+            return 0;
+        }
+#endif
 
 	for (i = 0; i < vi->max_queue_pairs; i++) {
 		if (i < vi->curr_queue_pairs)
@@ -2219,31 +2250,36 @@ static bool is_xdp_raw_buffer_queue(struct virtnet_info *vi, int q)
 		return false;
 }
 
-static void free_unused_bufs(struct virtnet_info *vi)
+static void free_unused_bufs(struct virtnet_info *vi, int flag)
 {
 	void *buf;
 	int i;
 
-	for (i = 0; i < vi->max_queue_pairs; i++) {
-		struct virtqueue *vq = vi->sq[i].vq;
+	if (flag == 1 || flag == 2) {
+		for (i = 0; i < vi->max_queue_pairs; i++) {
+			struct virtqueue *vq = vi->sq[i].vq;
+
 		while ((buf = virtqueue_detach_unused_buf(vq)) != NULL) {
-			if (!is_xdp_raw_buffer_queue(vi, i))
-				dev_kfree_skb(buf);
-			else
-				put_page(virt_to_head_page(buf));
+				if (!is_xdp_raw_buffer_queue(vi, i))
+					dev_kfree_skb(buf);
+				else
+					put_page(virt_to_head_page(buf));
+			}
 		}
 	}
 
-	for (i = 0; i < vi->max_queue_pairs; i++) {
-		struct virtqueue *vq = vi->rq[i].vq;
-
-		while ((buf = virtqueue_detach_unused_buf(vq)) != NULL) {
-			if (vi->mergeable_rx_bufs) {
-				put_page(virt_to_head_page(buf));
-			} else if (vi->big_packets) {
-				give_pages(&vi->rq[i], buf);
-			} else {
-				put_page(virt_to_head_page(buf));
+	if (flag == 0 || flag == 2) {
+		for (i = 0; i < vi->max_queue_pairs; i++) {
+			struct virtqueue *vq = vi->rq[i].vq;
+
+			while ((buf = virtqueue_detach_unused_buf(vq)) != NULL) {
+				if (vi->mergeable_rx_bufs) {
+					put_page(virt_to_head_page(buf));
+				} else if (vi->big_packets) {
+					give_pages(&vi->rq[i], buf);
+				} else {
+					put_page(virt_to_head_page(buf));
+				}
 			}
 		}
 	}
@@ -2685,6 +2721,10 @@ static int virtnet_probe(struct virtio_device *vdev)
 
 	virtnet_set_queues(vi, vi->curr_queue_pairs);
 
+#ifdef DEV_NETMAP
+        virtio_netmap_attach(vi);
+#endif
+
 	/* Assume link up if device can't report link status,
 	   otherwise get link status from config. */
 	if (virtio_has_feature(vi->vdev, VIRTIO_NET_F_STATUS)) {
@@ -2724,7 +2764,7 @@ static void remove_vq_common(struct virtnet_info *vi)
 	vi->vdev->config->reset(vi->vdev);
 
 	/* Free unused buffers in both send and recv, if any. */
-	free_unused_bufs(vi);
+	free_unused_bufs(vi, 3);
 
 	free_receive_bufs(vi);
 
@@ -2736,7 +2776,14 @@ static void remove_vq_common(struct virtnet_info *vi)
 static void virtnet_remove(struct virtio_device *vdev)
 {
 	struct virtnet_info *vi = vdev->priv;
+#ifdef DEV_NETMAP
+	/* Save the pointer, will go away after netmap_detach(). */
+	struct netmap_adapter *token = NA(vi->dev);
 
+	netmap_detach(vi->dev);
+	virtio_netmap_clean_used_rings(vi, token, 3);
+	virtio_netmap_reclaim_unused(vi, 3);
+#endif
 	virtnet_cpu_notif_remove(vi);
 
 	/* Make sure no work handler is accessing the device. */
@@ -2803,6 +2850,9 @@ static unsigned int features_legacy[] = {
 	VIRTNET_FEATURES,
 	VIRTIO_NET_F_GSO,
 	VIRTIO_F_ANY_LAYOUT,
+#ifdef VIRTIO_NET_F_PTNETMAP
+	VIRTIO_NET_F_PTNETMAP,
+#endif
 };
 
 static struct virtio_driver virtio_net_driver = {
