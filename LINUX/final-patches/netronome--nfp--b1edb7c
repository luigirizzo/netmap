diff --git a/nfp/src/nfd3/dp.c b/nfp/src/nfd3/dp.c
index 555f5c9..ca918b5 100644
--- a/nfp/src/nfd3/dp.c
+++ b/nfp/src/nfd3/dp.c
@@ -20,6 +20,11 @@
 #include "../crypto/fw.h"
 #include "nfd3.h"
 
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#define NETMAP_NFP_NFD3_DP
+#include <nfp_netmap_linux.h>
+#endif
+
 /* Transmit processing
  *
  * One queue controller peripheral queue is used for transmit.  The
@@ -649,6 +654,11 @@ void nfp_nfd3_rx_ring_fill_freelist(struct nfp_net_dp *dp,
 {
 	unsigned int i;
 
+#ifdef DEV_NETMAP
+	if (nfp_netmap_configure_rx_ring(dp, rx_ring))
+		return;
+#endif
+
 	if (nfp_net_has_xsk_pool_slow(dp, rx_ring->idx))
 		return nfp_net_xsk_rx_ring_fill_freelist(rx_ring);
 
@@ -940,6 +950,16 @@ static int nfp_nfd3_rx(struct nfp_net_rx_ring *rx_ring, int budget)
 	struct xdp_buff xdp;
 #endif
 
+#ifdef DEV_NETMAP
+	if (dp->netdev) {
+		int dummy, nm_irq;
+		nm_irq = netmap_rx_irq(dp->netdev, rx_ring->idx, &dummy);
+		if (nm_irq != NM_IRQ_PASS) {
+			return (nm_irq == NM_IRQ_COMPLETED) ? 1 : budget;
+		}
+	}
+#endif /* DEV_NETMAP */
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0)
 	rcu_read_lock();
 #endif
@@ -1023,6 +1043,12 @@ static int nfp_nfd3_rx(struct nfp_net_rx_ring *rx_ring, int budget)
 			nfp_nfd3_set_hash_desc(dp->netdev, &meta,
 					       rxbuf->frag + meta_off, rxd);
 		} else if (meta_len) {
+#ifdef DEV_NETMAP
+			if (!rxbuf->frag) {
+				nm_prlim(1, "null rxbuf->frag meta_len %d meta_off %x", meta_len, meta_off);
+				continue;
+			}
+#endif
 			if (unlikely(nfp_nfd3_parse_meta(dp->netdev, &meta,
 							 rxbuf->frag + meta_off,
 							 rxbuf->frag + pkt_off,
diff --git a/nfp/src/nfp_net.h b/nfp/src/nfp_net.h
index 999207a..dfcc9c2 100644
--- a/nfp/src/nfp_net.h
+++ b/nfp/src/nfp_net.h
@@ -951,8 +951,21 @@ extern const char nfp_driver_version[];
 extern const struct net_device_ops nfp_nfd3_netdev_ops;
 extern const struct net_device_ops nfp_nfdk_netdev_ops;
 
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#define NETMAP_NFP_NET
+#include <nfp_netmap_linux.h>
+#undef NETMAP_NFP_NET
+#endif
+
 static inline bool nfp_netdev_is_nfp_net(struct net_device *netdev)
 {
+#ifdef DEV_NETMAP
+	struct netmap_adapter *na = NA(netdev);
+	if (na && na->if_transmit) {
+		return na->if_transmit == (void *)&nfp_nfd3_netdev_ops ||
+		       na->if_transmit == (void *)&nfp_nfdk_netdev_ops;
+	}
+#endif /* DEV_NETMAP */
 	return netdev->netdev_ops == &nfp_nfd3_netdev_ops ||
 	       netdev->netdev_ops == &nfp_nfdk_netdev_ops;
 }
diff --git a/nfp/src/nfp_net_dp.c b/nfp/src/nfp_net_dp.c
index e92157c..2f94eab 100644
--- a/nfp/src/nfp_net_dp.c
+++ b/nfp/src/nfp_net_dp.c
@@ -5,6 +5,11 @@
 #include "nfp_net_dp.h"
 #include "nfp_net_xsk.h"
 
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#define NETMAP_NFP_DP
+#include <nfp_netmap_linux.h>
+#endif
+
 /**
  * nfp_net_rx_alloc_one() - Allocate and map page frag for RX
  * @dp:		NFP Net data path struct
@@ -209,6 +214,11 @@ int nfp_net_tx_rings_prepare(struct nfp_net *nn, struct nfp_net_dp *dp)
 		if (nfp_net_tx_ring_alloc(dp, &dp->tx_rings[r]))
 			goto err_free_prev;
 
+#ifdef DEV_NETMAP
+		if (nfp_netmap_configure_tx_ring(nn, &dp->tx_rings[r]))
+			continue;
+#endif /* DEV_NETMAP */
+
 		if (nfp_net_tx_ring_bufs_alloc(dp, &dp->tx_rings[r]))
 			goto err_free_ring;
 	}
@@ -368,6 +378,11 @@ int nfp_net_rx_rings_prepare(struct nfp_net *nn, struct nfp_net_dp *dp)
 		if (nfp_net_rx_ring_alloc(dp, &dp->rx_rings[r]))
 			goto err_free_prev;
 
+#ifdef DEV_NETMAP
+		if (nfp_netmap_preconfigure_rx_ring(dp, &dp->rx_rings[r]))
+			continue;
+#endif /* DEV_NETMAP */
+
 		if (nfp_net_rx_ring_bufs_alloc(dp, &dp->rx_rings[r]))
 			goto err_free_ring;
 	}
diff --git a/nfp/src/nfp_net_main.c b/nfp/src/nfp_net_main.c
index 80f13bd..2a2204d 100644
--- a/nfp/src/nfp_net_main.c
+++ b/nfp/src/nfp_net_main.c
@@ -35,6 +35,11 @@
 
 #define NFP_PF_CSR_SLICE_SIZE	(32 * 1024)
 
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#define NETMAP_NFP_MAIN
+#include <nfp_netmap_linux.h>
+#endif
+
 /**
  * nfp_net_get_mac_addr() - Get the MAC address.
  * @pf:       NFP PF handle
@@ -171,6 +176,10 @@ nfp_net_pf_init_vnic(struct nfp_pf *pf, struct nfp_net *nn, unsigned int id)
 #else
 			goto err_debugfs_vnic_clean;
 #endif
+
+#ifdef DEV_NETMAP
+			nfp_netmap_attach(nn);;
+#endif /* DEV_NETMAP */
 	}
 
 	return 0;
diff --git a/nfp/src/nfp_net_repr.h b/nfp/src/nfp_net_repr.h
index b342082..07844c8 100644
--- a/nfp/src/nfp_net_repr.h
+++ b/nfp/src/nfp_net_repr.h
@@ -13,6 +13,11 @@ struct nfp_port;
 
 #ifdef COMPAT__HAVE_METADATA_IP_TUNNEL
 #include <net/dst_metadata.h>
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#define NETMAP_NFP_NET
+#include <nfp_netmap_linux.h>
+#undef NETMAP_NFP_NET
+#endif
 #endif
 
 /**
@@ -82,6 +87,12 @@ extern const struct net_device_ops nfp_repr_netdev_ops;
 #ifdef COMPAT__HAVE_METADATA_IP_TUNNEL
 static inline bool nfp_netdev_is_nfp_repr(struct net_device *netdev)
 {
+#ifdef DEV_NETMAP
+	struct netmap_adapter *na = NA(netdev);
+	if (na && na->if_transmit) {
+		return na->if_transmit == (void *)&nfp_repr_netdev_ops;
+	}
+#endif /* DEV_NETMAP */
 	return netdev->netdev_ops == &nfp_repr_netdev_ops;
 }
 
